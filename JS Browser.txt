что такое window?	"<ol><li>Во-первых, это глобальный объект для JavaScript-кода, об этом более подробно говорится в главе&nbsp;<a href=""https://learn.javascript.ru/global-object"">Глобальный объект</a>.</li><li>Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.</li></ol>"	"<a href=""https://learn.javascript.ru/browser-environment"">https://learn.javascript.ru/browser-environment</a>"	dom
как узнать высоту окна браузера?	window.innerHeight		dom
что такое dom?	"<span style=""color: rgb(51, 51, 51);"">Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.</span>"		dom
что такое BOM?	"<span style=""color: rgb(51, 51, 51);"">Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.</span><div><div>Например:</div><ul><li>Объект&nbsp;<a href=""https://developer.mozilla.org/ru/docs/Web/API/Window/navigator"">navigator</a>&nbsp;даёт информацию о самом браузере и операционной системе.&nbsp;</li><li><span style=""color: rgb(51, 51, 51);"">Объект&nbsp;</span><a href=""https://developer.mozilla.org/ru/docs/Web/API/Window/location"">location</a><span style=""color: rgb(51, 51, 51);"">&nbsp;позволяет получить текущий URL и перенаправить браузер по новому адресу.</span></li></ul><div><span style=""color: rgb(51, 51, 51);"">BOM является частью общей&nbsp;</span><a href=""https://html.spec.whatwg.org/"">спецификации HTML</a><span style=""color: rgb(51, 51, 51);"">.</span><font color=""#333333""><br></font></div></div>"		dom
"как получить&nbsp;<span style=""color: rgb(51, 51, 51);"">информацию о текущем браузере?</span>"	"<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">navigator.userAgent</span>"		dom
Как получить информацию об ОС, в которой открыт браузер?	navigator.platform		dom
Как посмотреть текущий url?	"<font color=""#333333"">location.href</font>"		dom
"Как&nbsp;<span style=""color: rgb(51, 51, 51);"">перенаправить браузер по новому адресу?</span>"	"location.href = ""https://www.ya.ru"""		dom
"К чему относятся функции&nbsp;<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">alert/confirm/prompt</span>&nbsp;DOM или BOM?"	"BOM -&nbsp;<span style=""color: rgb(51, 51, 51);"">они не относятся непосредственно к странице, но представляют собой методы объекта окна браузера для коммуникации с пользователем</span>"		dom
"<span style=""color: rgb(51, 51, 51);"">объект для тега&nbsp;</span><code>&lt;body&gt;</code>"	"<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">document.body</span>"		dom
как сделать body красным?	<pre><code>document<code>.</code>body<code>.</code>style<code>.</code>background <code>=</code> <code>'red'</code><code>;</code></code></pre>		dom
Напишите простейшую структуру тегов html Документа	<pre><code><code>&lt;!DOCTYPE HTML&gt;</code> <code><code><code>&lt;</code>html</code><code>&gt;</code></code> <code><code><code>&lt;</code>head</code><code>&gt;</code></code>   <code><code><code>&lt;</code>title</code><code>&gt;</code></code>О лосях<code><code><code>&lt;/</code>title</code><code>&gt;</code></code> <code><code><code>&lt;/</code>head</code><code>&gt;</code></code> <code><code><code>&lt;</code>body</code><code>&gt;</code></code>   Правда о лосях. <code><code><code>&lt;/</code>body</code><code>&gt;</code></code> <code><code><code>&lt;/</code>html</code><code>&gt;</code></code></code></pre>		dom
могут ли быть потомки у текстового узла?	"нет,&nbsp;<span style=""color: rgb(51, 51, 51);"">он находится всегда на самом нижнем уровне.</span>"		dom
что выдаст браузер если тега html или body нет в документе?	он их создаст		dom
"что будет если&nbsp;<span style=""color: rgb(51, 51, 51);"">HTML-файл состоит из единственного слова&nbsp;</span><code>""Привет""</code>"	"<span style=""color: rgb(51, 51, 51);"">браузер обернёт ""Привет"" в теги&nbsp;</span><code>&lt;html&gt;</code><span style=""color: rgb(51, 51, 51);"">&nbsp;и&nbsp;</span><code>&lt;body&gt;</code><span style=""color: rgb(51, 51, 51);"">, добавит необходимый тег&nbsp;</span><code>&lt;head&gt;</code>"		dom
является ли комментарий узлом dom?	да		dom
как в html написать комментарий?	<pre><code>  <code>&lt;!-- комментарий --&gt;</code></code></pre>		dom
как в консоли браузера обратиться к последнему выбранному элементу?	$0		dom
"какой узел dom&nbsp;<span style=""color: rgb(51, 51, 51);"">соответствует тегу&nbsp;</span><code>&lt;html&gt;?</code>"	"<code>&lt;html&gt;</code><span style=""color: rgb(51, 51, 51); font-weight: 700;"">&nbsp;=&nbsp;</span><code>document.documentElement</code><br>"		dom
"<code>&lt;body&gt;</code><span style=""color: rgb(51, 51, 51); font-weight: 700;"">&nbsp;= ?</span>"	"<code>&lt;body&gt;</code><span style=""color: rgb(51, 51, 51); font-weight: 700;"">&nbsp;=&nbsp;</span><code>document.body</code>"		dom
"<code>&lt;head&gt;</code><span style=""color: rgb(51, 51, 51); font-weight: 700;"">&nbsp;=&nbsp;?</span>"	"<code>&lt;head&gt;</code><span style=""color: rgb(51, 51, 51); font-weight: 700;"">&nbsp;=&nbsp;</span><code>document.head</code>"		dom
"что выведет браузер?<div><br></div><div><pre><code><code><code><code>&lt;</code>html</code><code>&gt;</code></code>  <code><code><code>&lt;</code>head</code><code>&gt;</code></code>   <code><code><code>&lt;</code>script</code><code>&gt;</code></code><code><code>     <code>alert</code><code>(</code> <code>""Из HEAD: ""</code> <code>+</code> document<code>.</code>body <code>)</code><code>;</code> <code>// null, &lt;body&gt; ещё нет</code>   </code></code><code><code><code>&lt;/</code>script</code><code>&gt;</code></code> <code><code><code>&lt;/</code>head</code><code>&gt;</code></code>  <code><code><code>&lt;</code>body</code><code>&gt;</code></code> <code><code><code>&lt;/</code>body</code><code>&gt;</code></code> <code><code><code>&lt;/</code>html</code><code>&gt;</code></code></code></pre></div>"	<div>&nbsp;если скрипт находится в&nbsp;<code>&lt;head&gt;</code>,&nbsp;<code>document.body</code>&nbsp;в нём недоступен, потому что браузер его ещё не прочитал.</div><div>Поэтому, в примере <code>alert</code>&nbsp;выведет&nbsp;<code>null</code></div>		dom
что такое&nbsp;<strong><code>childNodes?</code></strong>	<strong>Коллекция&nbsp;<code>childNodes</code>&nbsp;содержит список всех детей, включая текстовые узлы.</strong>		dom
что такое&nbsp;<strong><code>firstChild</code>&nbsp;и&nbsp;<code>lastChild?</code></strong>	Свойства&nbsp;firstChild&nbsp;и&nbsp;lastChild&nbsp;обеспечивают быстрый доступ к первому и последнему дочернему элементу.		dom
как проверить наличие дочерних узлов?	"<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">elem.hasChildNodes()</span>"		dom
"что такое ""<em>коллекция""? </em>childNodes например&nbsp;"	"<span style=""color: rgb(51, 51, 51);"">особый перебираемый объект-псевдомассив</span>"		dom
как можно перебрать&nbsp;<em>коллекцию?&nbsp;</em>childNodes например&nbsp;	"<ol><li>Для перебора&nbsp;<em>коллекции</em>&nbsp;мы можем использовать&nbsp;<code>for..of</code>:</li></ol><div><div><div><pre><code><code>for</code> <code>(</code><code>let</code> node <code>of</code> document<code>.</code>body<code>.</code>childNodes<code>)</code> <code>{</code>   <code>alert</code><code>(</code>node<code>)</code><code>;</code> <code>// покажет все узлы из коллекции</code> <code>}</code></code></pre><pre><code><code>Это работает, потому что коллекция является перебираемым объектом (есть требуемый для этого метод&nbsp;<code>Symbol.iterator</code><span style=""color: rgb(51, 51, 51);"">)</span><br></code></code></pre></div></div></div>"		dom
будут ли работать методы массивов с коллекцией? childNodes например	"нет, потому что это не массив, а перебираемый псевдомассив<div><div>Если нам хочется использовать именно методы массива, то мы можем создать настоящий массив из коллекции, используя&nbsp;<code>Array.from</code>:</div><div><div><div><div><a href=""https://learn.javascript.ru/dom-navigation#""></a></div><div><a href=""https://learn.javascript.ru/dom-navigation#""></a></div></div><div><pre><code><code>alert</code><code>(</code> Array<code>.</code><code>from</code><code>(</code>document<code>.</code>body<code>.</code>childNodes<code>)</code><code>.</code>filter <code>)</code><code>;</code></code></pre></div></div></div></div>"		dom
чем отличаются дети от потомков?	<div>Здесь и далее мы будем использовать два принципиально разных термина:</div><ul><li><strong>Дочерние узлы (или дети)</strong>&nbsp;– элементы, которые являются непосредственными детьми узла. Другими словами, элементы, которые лежат непосредственно внутри данного. Например,&nbsp;<code>&lt;head&gt;</code>&nbsp;и&nbsp;<code>&lt;body&gt;</code>&nbsp;являются детьми элемента&nbsp;<code>&lt;html&gt;</code>.</li><li><strong>Потомки</strong>&nbsp;– все элементы, которые лежат внутри данного, включая детей, их детей и т.д.</li></ul>		dom
что такое соседи?	"<em>Соседи</em><span style=""color: rgb(51, 51, 51);"">&nbsp;– это узлы, у которых один и тот же родитель.</span><div><div>Например, здесь&nbsp;<code>&lt;head&gt;</code>&nbsp;и&nbsp;<code>&lt;body&gt;</code>&nbsp;соседи:</div><div><div><div><pre><code><code><code><code>&lt;</code>html</code><code>&gt;</code></code>   <code><code><code>&lt;</code>head</code><code>&gt;</code></code>...<code><code><code>&lt;/</code>head</code><code>&gt;</code></code><code><code><code>&lt;</code>body</code><code>&gt;</code></code>...<code><code><code>&lt;/</code>body</code><code>&gt;</code></code> <code><code><code>&lt;/</code>html</code><code>&gt;</code></code></code><span style=""background-color: rgb(231, 229, 227);""></span></pre></div></div></div><ul><li>говорят, что&nbsp;<code>&lt;body&gt;</code>&nbsp;– «следующий» или «правый» сосед&nbsp;<code>&lt;head&gt;</code></li><li>также можно сказать, что&nbsp;<code>&lt;head&gt;</code>&nbsp;«предыдущий» или «левый» сосед&nbsp;<code>&lt;body&gt;</code>.</li></ul></div>"		dom
"<span style=""color: rgb(51, 51, 51);"">Следующий узел того же родителя (следующий сосед) – в свойстве ...,&nbsp;</span><span style=""color: rgb(51, 51, 51);"">а предыдущий – в ...</span><span style=""color: rgb(51, 51, 51);"">?</span>"	"<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">nextSibling&nbsp;</span><span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">previousSibling</span>"		dom
"<span style=""color: rgb(51, 51, 51);"">Родитель узла доступен через ...?</span>"	"<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">parentNode</span>"		dom
"Навигация только по элементам<div><br></div><div><ul><li><font face=""monospace"">...</font>– коллекция детей, которые являются элементами.</li><li><code>...</code>,&nbsp;<font face=""monospace"">...</font>– первый и последний дочерний элемент.</li><li><code>...</code>,&nbsp;<font face=""monospace"">...</font>– соседи-элементы.</li><li><font face=""monospace"">...</font>– родитель-элемент.</li></ul></div>"	<ul><li><code>children</code>&nbsp;– коллекция детей, которые являются элементами.</li><li><code>firstElementChild</code>,&nbsp;<code>lastElementChild</code>&nbsp;– первый и последний дочерний элемент.</li><li><code>previousElementSibling</code>,&nbsp;<code>nextElementSibling</code>&nbsp;– соседи-элементы.</li><li><code>parentElement</code>&nbsp;– родитель-элемент.</li></ul>		dom
<div><strong>Элемент&nbsp;<code>&lt;table&gt;</code></strong>&nbsp;поддерживает следующие свойства:</div><ul><li><code>{{c1::table.rows}}</code>&nbsp;– коллекция строк&nbsp;<code>&lt;tr&gt;</code>&nbsp;таблицы.</li><li><code>{{c2::table.caption/tHead/tFoot}}</code>&nbsp;– ссылки на элементы таблицы&nbsp;<code>&lt;caption&gt;</code>,&nbsp;<code>&lt;thead&gt;</code>,&nbsp;<code>&lt;tfoot&gt;</code>.</li><li><code>{{c3::table.tBodies}}</code>&nbsp;– коллекция элементов таблицы&nbsp;<code>&lt;tbody&gt;</code>&nbsp;(по спецификации их может быть больше одного).</li></ul>		dom
<div><strong><code>&lt;thead&gt;</code>,&nbsp;<code>&lt;tfoot&gt;</code>,&nbsp;<code>&lt;tbody&gt;</code></strong>&nbsp;предоставляют свойство&nbsp;<code>{{c2::rows}}</code>:</div><ul><li><code>{{c1::tbody.rows}}</code>&nbsp;– коллекция строк&nbsp;<code>&lt;tr&gt;</code>&nbsp;секции.</li></ul>		dom
"<pre><span style=""color: rgb(28, 2, 255);"">&lt;<span style=""font-weight: 700;"">table</span>&gt;</span><span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c1::caption}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>Phone numbers<span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c2::caption}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>     <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c3::thead}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>         <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c4::tr}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>             <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c5::th}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>Name<span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c6::th}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>             <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c7::<span style=""font-weight: 700;"">th</span>}} <span style=""color: rgb(28, 2, 255);""><span style=""font-style: italic;"">colspan</span>=<span style=""color: rgb(216, 8, 0);"">""2""</span>&gt;</span>Phone<span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c8::th}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>         <span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c9::tr}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>     <span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c10::thead}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>     <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c11::tbody}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>         <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c12::tr}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>             <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c13::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>John<span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c14::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>             <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c17::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>577854<span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c15::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>             <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c18::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>577855<span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c16::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>         <span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c19::tr}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>     <span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c20::tbody}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>     <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c21::tfoot}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>         <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c22::tr}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>             <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c23::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span><span style=""color: rgb(197, 6, 11); font-style: italic;"">&amp;nbsp;</span><span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c24::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>             <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c28::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>Personal<span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c25::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>             <span style=""color: rgb(28, 2, 255);"">&lt;</span>{{c27::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>Office<span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c26::td}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>         <span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c29::tr}}<span style=""color: rgb(28, 2, 255);"">&gt;</span>     <span style=""color: rgb(28, 2, 255);"">&lt;/</span>{{c30::tfoot}}<span style=""color: rgb(28, 2, 255);"">&gt;</span> <span style=""color: rgb(28, 2, 255);"">&lt;/<span style=""font-weight: 700;"">table</span>&gt;</span></pre><pre><span style=""color: rgb(28, 2, 255);""><br></span></pre><pre><img src=""paste-35e8eb56364b79c1bd784d8f8db2b24ecfc5a149.jpg""><span style=""color: rgb(28, 2, 255);""><br></span></pre>"		dom
<div><strong><code>&lt;tr&gt;</code>:</strong></div><ul><li><code>tr.</code>{{c1::<code>cells</code>&nbsp;}}– коллекция&nbsp;<code>&lt;td&gt;</code>&nbsp;и&nbsp;<code>&lt;th&gt;</code>&nbsp;ячеек, находящихся внутри строки&nbsp;<code>&lt;tr&gt;</code>.</li><li><code>tr.</code>{{c2::<code>sectionRowIndex</code>&nbsp;}}– номер строки&nbsp;<code>&lt;tr&gt;</code>&nbsp;в текущей секции&nbsp;<code>&lt;thead&gt;/&lt;tbody&gt;/&lt;tfoot&gt;</code>.</li><li><code>tr.</code>{{c3::<code>rowIndex</code>&nbsp;}}– номер строки&nbsp;<code>&lt;tr&gt;</code>&nbsp;в таблице (включая все строки таблицы).</li></ul>		dom
<div><strong><code>&lt;td&gt;</code>&nbsp;and&nbsp;<code>&lt;th&gt;</code>:</strong></div><ul><li><code>td.</code>{{c1::<code>cellIndex</code>&nbsp;}}– номер ячейки в строке&nbsp;<code>&lt;tr&gt;</code>.</li></ul>		dom
"<div>Для страницы:</div><div><div><div><pre><code><code><code><code>&lt;</code>html</code><code>&gt;</code></code> <code><code><code>&lt;</code>body</code><code>&gt;</code></code>   <code><code><code>&lt;</code>div</code><code>&gt;</code></code>Пользователи:<code><code><code>&lt;/</code>div</code><code>&gt;</code></code>   <code><code><code>&lt;</code>ul</code><code>&gt;</code></code>     <code><code><code>&lt;</code>li</code><code>&gt;</code></code>Джон<code><code><code>&lt;/</code>li</code><code>&gt;</code></code>     <code><code><code>&lt;</code>li</code><code>&gt;</code></code>Пит<code><code><code>&lt;/</code>li</code><code>&gt;</code></code>   <code><code><code>&lt;/</code>ul</code><code>&gt;</code></code> <code><code><code>&lt;/</code>body</code><code>&gt;</code></code> <code><code><code>&lt;/</code>html</code><code>&gt;</code></code></code><span style=""background-color: rgb(231, 229, 227);""></span></pre></div></div></div><div>Напишите код, как получить…</div><ul><li>элемент&nbsp;<code>&lt;div&gt;</code>?</li><li><code>&lt;ul&gt;</code>?</li><li>второй&nbsp;<code>&lt;li&gt;</code>&nbsp;(с именем Пит)?</li></ul>"	"<div>Есть несколько способов для получения элементов, например:</div><div>DOM-узел элемента&nbsp;<code>&lt;div&gt;</code>:</div><div><div><div><pre><code>document<code>.</code>body<code>.</code>firstElementChild <code>// или</code> document<code>.</code>body<code>.</code>children<code>[</code><code>0</code><code>]</code> <code>// или (первый узел пробел, поэтому выбираем второй)</code> document<code>.</code>body<code>.</code>childNodes<code>[</code><code>1</code><code>]</code></code><span style=""background-color: rgb(231, 229, 227);""></span></pre></div></div></div><div>DOM-узел элемента&nbsp;<code>&lt;ul&gt;</code>:</div><div><div><div><pre><code>document<code>.</code>body<code>.</code>lastElementChild <code>// или</code> document<code>.</code>body<code>.</code>children<code>[</code><code>1</code><code>]</code></code><span style=""background-color: rgb(231, 229, 227);""></span></pre></div></div></div><div>Второй&nbsp;<code>&lt;li&gt;</code>&nbsp;(с именем Пит):</div><div><div><div><pre><code><code>// получаем &lt;ul&gt;, и его последнего ребёнка</code> document<code>.</code>body<code>.</code>lastElementChild<code>.</code>lastElementChild</code></pre></div></div></div>"	dom
<div>Если&nbsp;<code>elem</code>&nbsp;– произвольный узел DOM-элемента…</div><ul><li>Правда, что&nbsp;<code>elem.lastChild.nextSibling</code>&nbsp;всегда равен&nbsp;<code>null</code>?</li><li>Правда, что&nbsp;<code>elem.children[0].previousSibling</code>&nbsp;всегда равен&nbsp;<code>null</code>&nbsp;?</li></ul>	<ol><li>Да. Верно. Элемент&nbsp;<code>elem.lastChild</code>&nbsp;всегда последний, у него нет ссылки&nbsp;<code>nextSibling</code>.</li><li>Нет. Неверно. Потому что&nbsp;<code>elem.children[0]</code>&nbsp;– потомок-элемент. Но перед ним могут быть другие узлы. Например,&nbsp;<code>previousSibling</code>&nbsp;может быть текстовым узлом.</li></ol><div>Обратите внимание, что в обоих случаях, если детей нет, то будет ошибка. При этом&nbsp;<code>elem.lastChild</code>&nbsp;равен&nbsp;<code>null</code>, а значит – ошибка при попытке доступа к&nbsp;<code>elem.lastChild.nextSibling</code>.</div>	dom
"<span style=""color: rgb(51, 51, 51);"">Если у элемента есть атрибут&nbsp;</span><code>id</code><span style=""color: rgb(51, 51, 51);"">, то мы можем получить его вызовом&nbsp;</span><code>{{c1::document.getElementById}}(id)</code><span style=""color: rgb(51, 51, 51);"">, где бы он ни находился.</span>"		dom
"Как обратиться к элементам div?<div><br></div><div><pre><code><code><code><code>&lt;</code>div</code> <code>id</code><code><code>=</code><code>""</code>elem<code>""</code></code><code>&gt;</code></code>   <code><code><code>&lt;</code>div</code> <code>id</code><code><code>=</code><code>""</code>elem-content<code>""</code></code><code>&gt;</code></code>Элемент<code><code><code>&lt;/</code>div</code><code>&gt;</code></code> <code><code><code>&lt;/</code>div</code><code>&gt;</code></code></code></pre></div>"	"1.&nbsp;<span style=""color: rgb(51, 51, 51);"">Если у элемента есть атрибут&nbsp;</span><code>id</code><span style=""color: rgb(51, 51, 51);"">, то мы можем получить его вызовом&nbsp;</span><code>document.getElementById(id)</code><span style=""color: rgb(51, 51, 51);"">, где бы он ни находился.</span><div><span style=""color: rgb(51, 51, 51);""><br></span></div><div><span style=""color: rgb(51, 51, 51);"">2.&nbsp;</span><span style=""color: rgb(51, 51, 51);"">Также есть глобальная переменная с именем, указанным в&nbsp;</span><code>id</code><span style=""color: rgb(51, 51, 51);"">:</span></div><div><pre><code><code><code>elem<code>.</code>style<code>.</code>background <code>=</code> <code>'red'</code><code>;</code></code></code></code></pre><pre><code><code><code><code><pre><code><code><code><code>// внутри id=""elem-content"" есть дефис, так что такой id не может служить именем переменной</code> <code>// ...но мы можем обратиться к нему через квадратные скобки: window['elem-content']</code></code></code></code></pre><pre><code><code><code><code><div><span style=""font-weight: 700;"">Пожалуйста, не используйте такие глобальные переменные для доступа к элементам</span></div><div><div>Это поведение соответствует&nbsp;<a href=""http://www.whatwg.org/specs/web-apps/current-work/#dom-window-nameditem"">стандарту</a>, но поддерживается в основном для совместимости, как осколок далёкого прошлого.</div><div>Браузер пытается помочь нам, смешивая пространства имён JS и DOM. Это удобно для простых скриптов, которые находятся прямо в HTML, но, вообще говоря, не очень хорошо. Возможны конфликты имён. Кроме того, при чтении JS-кода, не видя HTML, непонятно, откуда берётся переменная.</div><div><span style=""font-family: Arial; color: rgb(51, 51, 51);"">В реальной жизни лучше использовать&nbsp;</span><code>document.getElementById</code><span style=""font-family: Arial; color: rgb(51, 51, 51);"">.</span></div></div></code></code></code></code></pre></code></code></code></code></pre></div>"	dom
"<span style=""color: rgb(51, 51, 51);"">Самый универсальный метод поиска – это&nbsp;</span><code>elem.{{c1::querySelectorAll}}(css)</code><span style=""color: rgb(51, 51, 51);"">, он возвращает все элементы внутри&nbsp;</span><code>elem</code><span style=""color: rgb(51, 51, 51);"">, удовлетворяющие данному CSS-селектору.</span>"		dom
"<code>document.querySelectorAll(':hover')</code><span style=""color: rgb(51, 51, 51);"">&nbsp;вернёт&nbsp;</span>{{c1::коллекцию (в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши.}}"		dom
"<span style=""color: rgb(51, 51, 51);"">Метод&nbsp;</span><code>elem.querySelector(css)</code><span style=""color: rgb(51, 51, 51);"">&nbsp;возвращает&nbsp;</span>{{c1::первый элемент, соответствующий данному CSS-селектору}}<span style=""color: rgb(51, 51, 51);"">.</span>"		dom
"<span style=""color: rgb(51, 51, 51);"">Метод&nbsp;</span><a href=""http://dom.spec.whatwg.org/#dom-element-matches"">elem.matches(css)</a><span style=""color: rgb(51, 51, 51);"">&nbsp;ничего не ищет, а проверяет,&nbsp;</span>{{c1::<span style=""color: rgb(51, 51, 51);"">удовлетворяет ли&nbsp;</span><code>elem</code><span style=""color: rgb(51, 51, 51);"">&nbsp;CSS-селектору,</span>}}<span style=""color: rgb(51, 51, 51);"">&nbsp;и возвращает</span>{{c2::<span style=""color: rgb(51, 51, 51);"">&nbsp;</span><code>true</code><span style=""color: rgb(51, 51, 51);"">&nbsp;или&nbsp;</span><code>false.</code>}}"	"<span style=""color: rgb(51, 51, 51);"">Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.</span>"	dom
"<span style=""color: rgb(51, 51, 51);"">Метод&nbsp;</span><code>elem.closest(css)</code><span style=""color: rgb(51, 51, 51);"">&nbsp;ищет&nbsp;</span>{{c1::ближайшего предка, который соответствует CSS-селектору}}<span style=""color: rgb(51, 51, 51);"">. Сам элемент также включается в поиск.</span>"	"<span style=""color: rgb(51, 51, 51);"">Другими словами, метод&nbsp;</span><code>closest</code><span style=""color: rgb(51, 51, 51);"">&nbsp;поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо&nbsp;</span><code>null</code><span style=""color: rgb(51, 51, 51);"">, если такой элемент не найден.</span>"	dom
"Исторические альтернативы современному `querySelector`:<div><ul><li><code>elem.{{c1::getElementsByTagName}}(tag)</code>&nbsp;ищет элементы с данным тегом и возвращает их коллекцию. Передав&nbsp;<code>""*""</code>&nbsp;вместо тега, можно получить всех потомков.</li><li><code>elem.{{c2::getElementsByClassName}}(className)</code>&nbsp;возвращает элементы, которые имеют данный CSS-класс.</li><li><code>document.{{c3::getElementsByName}}(name)</code>&nbsp;возвращает элементы с заданным атрибутом&nbsp;<code>name</code>. Очень редко используется.</li></ul></div><div><br></div>"		dom
"<span style=""color: rgb(51, 51, 51);"">Все методы&nbsp;</span><code>""getElementsBy*""</code><span style=""color: rgb(51, 51, 51);"">&nbsp;возвращают&nbsp;</span><em>живую/</em><em>статическую?</em><span style=""color: rgb(51, 51, 51);"">&nbsp;коллекцию.</span><div><span style=""color: rgb(51, 51, 51);"">Напротив,&nbsp;</span><code>querySelectorAll</code><span style=""color: rgb(51, 51, 51);"">&nbsp;возвращает&nbsp;</span><em>живую/</em><em>статическую?</em><span style=""color: rgb(51, 51, 51);"">&nbsp;коллекцию.&nbsp;</span></div>"	"<span style=""color: rgb(51, 51, 51);"">Все методы&nbsp;</span><code>""getElementsBy*""</code><span style=""color: rgb(51, 51, 51);"">&nbsp;возвращают&nbsp;</span><em>живую</em><span style=""color: rgb(51, 51, 51);"">&nbsp;коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.</span><div><span style=""color: rgb(51, 51, 51);""><br></span></div><div><span style=""color: rgb(51, 51, 51);"">Напротив,&nbsp;</span><code>querySelectorAll</code><span style=""color: rgb(51, 51, 51);"">&nbsp;возвращает&nbsp;</span><em>статическую</em><span style=""color: rgb(51, 51, 51);"">&nbsp;коллекцию. Это похоже на фиксированный массив элементов.</span><span style=""color: rgb(51, 51, 51);""><br></span></div>"	dom
"<code>elemA.{{c1::contains}}(elemB)</code><span style=""color: rgb(51, 51, 51);"">&nbsp;вернёт&nbsp;</span><code>true</code><span style=""color: rgb(51, 51, 51);"">, если&nbsp;</span><code>elemB</code><span style=""color: rgb(51, 51, 51);"">&nbsp;находится внутри&nbsp;</span><code>elemA</code><span style=""color: rgb(51, 51, 51);"">&nbsp;(</span><code>elemB</code><span style=""color: rgb(51, 51, 51);"">&nbsp;потомок&nbsp;</span><code>elemA</code><span style=""color: rgb(51, 51, 51);"">) или когда&nbsp;</span><code>elemA==elemB</code>"		dom
Дерево наследования классов для HTML элемента:<br>	"EventTarget -&gt; Node -&gt; Element -&gt; HTMLElement<div><br></div><div><ul><li><img src=""paste-a4f3ca4eba0cce9621fba471ce0e93d8951b419d.jpg""><br></li></ul></div>"	dom
"<span style=""color: rgb(51, 51, 51);"">Свойство&nbsp;</span><a href=""https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML"">{{c1::innerHTML}}</a><span style=""color: rgb(51, 51, 51);"">&nbsp;позволяет получить HTML-содержимое элемента в виде строки.</span>"		dom
"<span style=""color: rgb(51, 51, 51);"">Получив DOM-узел, мы можем узнать имя его тега из свойств&nbsp;</span><code>{{c1::nodeName}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;и&nbsp;</span><code>{{c2::tagName}}</code>"		dom
"<span style=""color: rgb(51, 51, 51);"">Свойство&nbsp;</span><code>{{c1::outerHTML}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;содержит HTML элемента целиком. Это как&nbsp;</span><code>innerHTML</code><span style=""color: rgb(51, 51, 51);"">&nbsp;плюс сам элемент.</span>"		dom
<pre><code><code><code><code>Прочитаем содержимое текстового узла и комментария:<br></code></code></code></code></pre><pre><code><code><code><code>&lt;</code>body</code><code>&gt;</code></code>   Привет   <code>&lt;!-- Комментарий --&gt;</code>   <code><code><code>&lt;</code>script</code><code>&gt;</code></code><code><code>     <code>let</code> text <code>=</code> document<code>.</code>body<code>.</code>firstChild<code>;</code>     {{c1::<code>alert</code><code>(</code>text<code>.</code>data<code>)</code><code>;</code>}} <code>// Привет</code>      <code>let</code> comment <code>=</code> text<code>.</code>nextSibling<code>;</code>     {{c2::<code>alert</code><code>(</code>comment<code>.</code>data<code>)</code><code>;</code>}} <code>// Комментарий</code>   </code></code><code><code><code>&lt;/</code>script</code><code>&gt;</code></code> <code><code><code>&lt;/</code>body</code><code>&gt;</code></code></code></pre>		dom
"<div><span style=""color: rgb(51, 51, 51);"">Свойство `</span><code>textContent`</code><span style=""color: rgb(51, 51, 51);"">&nbsp;предоставляет доступ к&nbsp;</span><em>тексту</em><span style=""color: rgb(51, 51, 51);"">&nbsp;внутри элемента за вычетом всех&nbsp;</span><code>&lt;тегов&gt;</code><span style=""color: rgb(51, 51, 51);"">.</span><br></div>Возможность записывать текст в `textContent` позволяет писать текст «безопасным способом».<div>Объясните почему это безопаснее, чем `innerHTML`?</div>"	<div>Представим, что у нас есть произвольная строка, введённая пользователем, и мы хотим показать её.</div><ul><li>С&nbsp;<code>innerHTML</code>&nbsp;вставка происходит «как HTML», со всеми HTML-тегами.</li><li>С&nbsp;<code>textContent</code>&nbsp;вставка получается «как текст», все символы трактуются буквально.</li></ul><div>В большинстве случаев мы рассчитываем получить от пользователя текст и хотим, чтобы он интерпретировался как текст. Мы не хотим, чтобы на сайте появлялся произвольный HTML-код. Присваивание через&nbsp;<code>textContent</code>&nbsp;– один из способов от этого защититься.</div>	dom
"Как спрятать элемент?&nbsp;<code><code>&lt;</code>div</code> <code>id</code><code><code>=</code><code>""</code>elem<code>""</code></code><code>&gt;Text</code><code><code>&lt;/</code>div</code><code>&gt;</code>"	"<code><code>1. &lt;</code>div</code>&nbsp;<code>id</code><code><code>=</code><code>""</code>elem<code>"" hidden</code></code><code>&gt;Text</code><code><code>&lt;/</code>div</code><code>&gt;</code><div><code>2.&nbsp;</code><code><code>&lt;</code>script</code><code>&gt;</code></div><pre><code><code><code>  elem<code>.</code>hidden <code>=</code> <code>true</code><code>;</code> </code></code><code><code><code>&lt;/</code>script</code><code>&gt;</code></code></code></pre>"	dom
"<div>Что выведет этот код?</div><div><div><div><pre><code><code><code><code>&lt;</code>script</code><code>&gt;</code></code><code><code>   <code>let</code> body <code>=</code> document<code>.</code>body<code>;</code>    body<code>.</code>innerHTML <code>=</code> <code>""&lt;!--""</code> <code>+</code> body<code>.</code>tagName <code>+</code> <code>""--&gt;""</code><code>;</code>    <code>alert</code><code>(</code> body<code>.</code>firstChild<code>.</code>data <code>)</code><code>;</code> <code>// что выведет?</code> </code></code><code><code><code>&lt;/</code>script</code><code>&gt;</code></code></code></pre></div></div></div>"	"<div>Ответ:&nbsp;<strong><code>BODY</code></strong>.</div><div><div><div><div><a href=""https://learn.javascript.ru/basic-dom-node-properties#""></a></div><div><a href=""https://learn.javascript.ru/basic-dom-node-properties#""></a></div></div><div><pre><code><code><code><code>&lt;</code>script</code><code>&gt;</code></code><code><code>   <code>let</code> body <code>=</code> document<code>.</code>body<code>;</code>    body<code>.</code>innerHTML <code>=</code> <code>""&lt;!--""</code> <code>+</code> body<code>.</code>tagName <code>+</code> <code>""--&gt;""</code><code>;</code>    <code>alert</code><code>(</code> body<code>.</code>firstChild<code>.</code>data <code>)</code><code>;</code> <code>// BODY</code> </code></code><code><code><code>&lt;/</code>script</code><code>&gt;</code></code></code><span style=""background-color: rgb(231, 229, 227);""></span></pre></div></div></div><div>Происходящее по шагам:</div><ol><li>Заменяем содержимое&nbsp;<code>&lt;body&gt;</code>&nbsp;на комментарий. Он будет иметь вид&nbsp;<code>&lt;!--BODY--&gt;</code>, т.к.&nbsp;<code>body.tagName == ""BODY""</code>. Как мы помним, свойство&nbsp;<code>tagName</code>&nbsp;в HTML всегда находится в верхнем регистре.</li><li>Этот комментарий теперь является первым и единственным потомком&nbsp;<code>body.firstChild</code>.</li><li>Значение свойства&nbsp;<code>data</code>&nbsp;для элемента-комментария – это его содержимое (внутри&nbsp;<code>&lt;!--...--&gt;</code>):&nbsp;<code>""BODY""</code>.</li></ol>"	dom
"<pre><code><code><code><code>В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов, он распознаёт&nbsp;<span style=""color: rgb(51, 51, 51);"">атрибуты и создаёт DOM-свойства для них.</span><br></code></code></code></code></pre><pre><code><code><code><code><span style=""color: rgb(51, 51, 51);"">Преобразуется ли в свойство следующие атрибуты?</span></code></code></code></code></pre><pre><code><code><code><code>&lt;</code>body</code> <code>id</code><code><code>=</code><code>""</code>test<code>""</code></code> <code>something</code><code><code>=</code><code>""</code>non-standard<code>""</code></code><code>&gt;</code></code>   <code><code><code>&lt;</code>script</code><code>&gt;</code></code><code><code>     <code>alert</code><code>(</code>document<code>.</code>body<code>.</code>id<code>)</code><code>;</code> // ??     <code>alert</code><code>(</code>document<code>.</code>body<code>.</code>something<code>)</code><code>; // ??</code>    </code></code><code><code><code>&lt;/</code>script</code><code>&gt;</code></code> <code><code><code>&lt;/</code>body</code><code>&gt;</code></code></code></pre>"	Браузер распознаёт только стандартные атрибуты.<div><pre><code><code><code><code>alert</code><code>(</code>document<code>.</code>body<code>.</code>id<code>)</code><code>;</code> <code>// test</code>     <code>// нестандартный атрибут не преобразуется в свойство</code>     <code>alert</code><code>(</code>document<code>.</code>body<code>.</code>something<code>)</code><code>;</code> <code>// undefined</code></code></code></code></pre></div><div><br></div>	dom
"<span style=""color: rgb(51, 51, 51);"">В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов, он распознаёт&nbsp;</span><em>стандартные</em><span style=""color: rgb(51, 51, 51);"">&nbsp;атрибуты и создаёт DOM-свойства для них.</span><div><span style=""color: rgb(51, 51, 51);"">Для нестандартных атрибутов не будет соответствующих DOM-свойств. Есть ли способ получить такие атрибуты?</span></div>"	"<div>Конечно. Все атрибуты доступны с помощью следующих методов:</div><ul><li><code>elem.hasAttribute(name)</code>&nbsp;– проверяет наличие атрибута.</li><li><code>elem.getAttribute(name)</code>&nbsp;– получает значение атрибута.</li><li><code>elem.setAttribute(name, value)</code>&nbsp;– устанавливает значение атрибута.</li><li><code>elem.removeAttribute(name)</code>&nbsp;– удаляет атрибут.</li></ul><div><span style=""color: rgb(51, 51, 51);"">Кроме этого, получить все атрибуты элемента можно с помощью свойства&nbsp;</span><code>elem.attributes</code><span style=""color: rgb(51, 51, 51);"">: коллекция объектов, которая принадлежит ко встроенному классу&nbsp;</span><a href=""https://dom.spec.whatwg.org/#attr"">Attr</a><span style=""color: rgb(51, 51, 51);"">&nbsp;со свойствами&nbsp;</span><code>name</code><span style=""color: rgb(51, 51, 51);"">&nbsp;и&nbsp;</span><code>value</code><span style=""color: rgb(51, 51, 51);"">.</span><br></div>"	dom
"<span style=""color: rgb(51, 51, 51);"">Когда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется. Это работает и в обратную сторону (за некоторыми исключениями). Какими исключениями?</span>"	"<code>input.value</code><span style=""color: rgb(51, 51, 51);"">&nbsp;синхронизируется только в одну сторону – атрибут → значение, но не в обратную:</span><div><pre><code><code><code>input<code>.</code><code>setAttribute</code><code>(</code><code>'value'</code><code>,</code> <code>'text'</code><code>)</code><code>;</code>   <code>alert</code><code>(</code>input<code>.</code>value<code>)</code><code>;</code> <code>// text</code>    <code>// свойство =&gt; атрибут</code>   input<code>.</code>value <code>=</code> <code>'newValue'</code><code>;</code>   <code>alert</code><code>(</code>input<code>.</code><code>getAttribute</code><code>(</code><code>'value'</code><code>)</code><code>)</code><code>;</code> <code>// text (не обновилось!)</code> </code></code><br></code></pre></div>"	dom
"<div>Но с пользовательскими атрибутами могут возникнуть проблемы. Что если мы используем нестандартный атрибут для наших целей, а позже он появится в стандарте и будет выполнять какую-то функцию? Язык HTML живой, он растёт, появляется больше атрибутов, чтобы удовлетворить потребности разработчиков. В этом случае могут возникнуть неожиданные эффекты.</div><div>Чтобы избежать конфликтов, существуют атрибуты вида&nbsp;<a href=""https://html.spec.whatwg.org/#embedding-custom-non-visible-data-with-the-data-*-attributes"">{{c1::data}}-*</a>.</div><div><strong>Все атрибуты, начинающиеся с префикса «</strong>{{c1::data}}<strong>-», зарезервированы для использования программистами. Они доступны в свойстве&nbsp;</strong>{{c1::dataset}}<strong>.</strong></div>"	"<span style=""color: rgb(51, 51, 51);"">Например, если у&nbsp;</span><code>elem</code><span style=""color: rgb(51, 51, 51);"">&nbsp;есть атрибут&nbsp;</span><code>""data-about""</code><span style=""color: rgb(51, 51, 51);"">, то обратиться к нему можно как&nbsp;</span><code>elem.dataset.about</code><span style=""color: rgb(51, 51, 51);"">.</span><div><span style=""color: rgb(51, 51, 51);"">Атрибуты, состоящие из нескольких слов, к примеру&nbsp;</span><code>data-order-state</code><span style=""color: rgb(51, 51, 51);"">, становятся свойствами, записанными с помощью верблюжьей нотации:&nbsp;</span><code>dataset.orderState</code><span style=""color: rgb(51, 51, 51);"">.</span><span style=""color: rgb(51, 51, 51);""><br></span></div>"	dom
<div>DOM-узел можно создать двумя методами:</div><dl><dt><code>{{c1::document.createElement}}(tag)</code></dt><dd><div>Создаёт новый&nbsp;<em>элемент</em>&nbsp;с заданным тегом</div><div><br></div></dd><dt><code>{{c1::document.createTextNode}}(text)</code></dt><dd><div>Создаёт новый&nbsp;<em>текстовый узел</em>&nbsp;с заданным текстом</div><div><pre><br></pre></div></dd></dl>	<pre><code><code>let</code> div <code>=</code> document<code>.</code><code>createElement</code><code>(</code><code>'div'</code><code>)</code><code>;</code></code></pre><pre><code><code><pre><code><code>let</code> textNode <code>=</code> document<code>.</code><code>createTextNode</code><code>(</code><code>'А вот и я'</code><code>)</code><code>;</code></code></pre></code></code></pre>	dom
как вставить в body элемент div?	document.body.append(div)	dom
"<code>node.{{c1::append}}(...nodes or strings)</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– добавляет узлы или строки в конец&nbsp;</span><code>node</code>"		dom
"<code>node.{{c1::prepend}}(...nodes or strings)</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– вставляет узлы или строки в начало&nbsp;</span><code>node</code>"		dom
"<code>node.{{c1::before}}(...nodes or strings)</code><span style=""color: rgb(51, 51, 51);"">&nbsp;–- вставляет узлы или строки до&nbsp;</span><code>node</code>"		dom
"<code>node.{{c1::after}}(...nodes or strings)</code><span style=""color: rgb(51, 51, 51);"">&nbsp;–- вставляет узлы или строки после&nbsp;</span><code>node</code>"		dom
"<code>node.{{c1::replaceWith}}(...nodes or strings)</code><span style=""color: rgb(51, 51, 51);"">&nbsp;–- заменяет&nbsp;</span><code>node</code><span style=""color: rgb(51, 51, 51);"">&nbsp;заданными узлами или строками</span>"		dom
"Что делает метод <span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">elem.insertAdjacentHTML(where, html)</span>?"	"Вставляет html-код в произвольную часть dom.&nbsp;<div><br></div><div><ul><li><code>""beforebegin""</code>&nbsp;– вставить&nbsp;<code>html</code>&nbsp;непосредственно перед&nbsp;<code>elem</code>,</li><li><code>""afterbegin""</code>&nbsp;– вставить&nbsp;<code>html</code>&nbsp;в начало&nbsp;<code>elem</code>,</li><li><code>""beforeend""</code>&nbsp;– вставить&nbsp;<code>html</code>&nbsp;в конец&nbsp;<code>elem</code>,</li><li><code>""afterend""</code>&nbsp;– вставить&nbsp;<code>html</code>&nbsp;непосредственно после&nbsp;<code>elem</code>.</li></ul><br></div>"	dom
"Какие варианты параметра where существуют у метода&nbsp;<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">elem.insertAdjacentHTML(where, html)</span>?"	"<ul><li><code>""beforebegin""</code>&nbsp;– вставить&nbsp;<code>html</code>&nbsp;непосредственно перед&nbsp;<code>elem</code>,</li><li><code>""afterbegin""</code>&nbsp;– вставить&nbsp;<code>html</code>&nbsp;в начало&nbsp;<code>elem</code>,</li><li><code>""beforeend""</code>&nbsp;– вставить&nbsp;<code>html</code>&nbsp;в конец&nbsp;<code>elem</code>,</li><li><code>""afterend""</code>&nbsp;– вставить&nbsp;<code>html</code>&nbsp;непосредственно после&nbsp;<code>elem</code></li></ul>"	dom
<div>Для удаления узла node есть метод&nbsp;<code>{{c1::node.remove()}}</code>.</div><br>		dom
"<span style=""color: rgb(51, 51, 51);"">Вызов&nbsp;</span><code>elem.{{c1::cloneNode(true)}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. Если мы вызовем&nbsp;</span><code>elem.{{c1::cloneNode(false)}}</code><span style=""color: rgb(51, 51, 51);"">, тогда клон будет без дочерних элементов</span>"		dom
Для чего используется DocumentFragment?	<div><code>DocumentFragment</code>&nbsp;является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.</div><div>Мы можем добавить к нему другие узлы, но когда мы вставляем его куда-то, он «исчезает», вместо него вставляется его содержимое.</div>	dom
"<span style=""color: rgb(51, 51, 51);"">Месяцы в JS начинаются от 0 или 1?</span>"	от 0	
"Свойство <code>elem.{{c1::className}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;соответствует атрибуту&nbsp;</span><code>""class""</code><span style=""color: rgb(51, 51, 51);"">.</span>"		dom
"<code>elem.{{c1::classList.add/remove}}(""class"")</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– добавить/удалить класс.</span>"		dom
"<code>elem.{{c1::classList.toggle}}(""class"")</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– добавить класс, если его нет, иначе удалить.</span>"		dom
"<code>elem.{{c1::classList.contains}}(""class"")</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– проверка наличия класса, возвращает&nbsp;</span><code>true/false</code><span style=""color: rgb(51, 51, 51);"">.</span>"		dom
<pre><code>background<code>-</code><code>color</code>  <code>=&gt;</code> elem<code>.</code>style<code>.</code>{{c1::backgroundColor}} z<code>-</code><code>index</code>           <code>=&gt;</code> elem<code>.</code>style<code>.</code>{{c1::zIndex}} border<code>-</code>left<code>-</code><code>width</code> <code>=&gt;</code> elem<code>.</code>style<code>.</code>{{c1::borderLeftWidth}}</code></pre>		dom
"<span style=""color: rgb(51, 51, 51);"">Для задания нескольких стилей в одной строке используется специальное свойство&nbsp;</span><code>style.{{c1::cssText}}</code>"	"<pre><code><code><code>div<code>.</code>style<code>.</code>cssText<code>=</code><code><code>`color: red !important;     background-color: yellow;     width: 100px;     text-align: center;   `</code></code><code>;</code></code></code></code></pre><pre><span style=""font-family: Arial;"">Это свойство редко используется, потому что такое присваивание удаляет все существующие стили: оно не добавляет, а заменяет их.</span><br></pre><pre>То же самое можно сделать установкой атрибута:&nbsp;div.setAttribute('style', 'color: red...').<span style=""font-family: Arial;""><br></span></pre>"	dom
"{{c1::<em>Вычисленное</em><span style=""color: rgb(51, 51, 51);"">&nbsp;(computed)</span>}}<span style=""color: rgb(51, 51, 51);"">&nbsp;значение CSS-свойства – это то, которое получено после применения всех CSS-правил и CSS-наследования.</span>"		dom
"<em>Окончательное</em><span style=""color: rgb(51, 51, 51);"">&nbsp;(</span><a href=""https://drafts.csswg.org/cssom/#resolved-values"">resolved</a><span style=""color: rgb(51, 51, 51);"">) значение CSS свойства - ?</span>"	"<span style=""color: rgb(51, 51, 51);"">Значение свойства, непосредственно применяемое к элементу. Например:</span><div><code>font-size:125%</code><span style=""color: rgb(51, 51, 51);"">&nbsp;относительное</span></div><div><code>font-size:16px</code>&nbsp;абсолютное</div>"	dom
"<span style=""color: rgb(51, 51, 51);"">В свойстве элемента&nbsp;</span><code>{{c1::offsetParent}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;находится предок элемента, который используется внутри браузера для вычисления координат при рендеринге.</span>"		dom
"<span style=""color: rgb(51, 51, 51);"">Свойства&nbsp;</span><code>{{c1::offsetLeft/offsetTop}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;содержат координаты x/y относительно верхнего левого угла&nbsp;</span><code>offsetParent</code><span style=""color: rgb(51, 51, 51);"">.</span>"		dom
"<span style=""color: rgb(51, 51, 51);"">Внешняя ширина блока&nbsp;</span>offsetWidth = {{c1::width}} + {{c1::padding}} + {{c1::border}}"	ширина под scrollbar вычитается из width:<div>width = content width + scrollbar</div>	dom
"<span style=""color: rgb(51, 51, 51);"">Свойства-метрики&nbsp;</span><code>clientTop</code><span style=""color: rgb(51, 51, 51);"">&nbsp;и&nbsp;</span><code>clientLeft равны</code>"	border-width	dom
clientWidth = {{c1::content width}} + {{c1::padding}}	"Но без scrollbar!<div><img src=""paste-9f145489062667cfb44192ae1c52e9294c37370c.jpg""><br></div><div><br></div>"	dom
Чему будет равен clientWidth и clientHeight, если width = 300px, height = 200px, scrollbar = 16px, padding = 0?	"clientWidth = content width = width - scrollbar = 284<div>clientHeight = height = 200<br></div><div><br></div><div><img src=""paste-fac8c16487901f560b247415f28254a7aa6142de.jpg""><br></div>"	dom
scrollWidth/Height - ?	"<div><img src=""paste-b61a9456254e5ec0c684948498fbe7d481095426.jpg""><br></div><div><br></div><div>На рисунке выше:</div><ul><li><code>scrollHeight = 723</code>&nbsp;– полная внутренняя высота, включая прокрученную область.</li><li><code>scrollWidth = 324</code>&nbsp;– полная внутренняя ширина, в данном случае прокрутки нет, поэтому она равна&nbsp;<code>clientWidth</code>.</li></ul><div>Эти свойства можно использовать, чтобы «распахнуть» элемент на всю ширину/высоту.</div>"	dom
"<span style=""color: rgb(51, 51, 51);"">Свойства&nbsp;</span><code>scrollLeft/scrollTop</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– ?</span>"	"<span style=""color: rgb(51, 51, 51);"">Ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.</span><div><span style=""color: rgb(51, 51, 51);""><br></span></div><div><img src=""paste-9fa533e389f13b99dfa7322db748d3e2c37e0436.jpg""><span style=""color: rgb(51, 51, 51);""><br></span></div>"	dom
Как выполнить прокрутку scrollbar`a в коде?	"Изменить свойство&nbsp;<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">scrollLeft/scrollTop</span>:<div><br><div><span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">elem.scrollTop += 10</span> - прокрутит вниз на 10px<br></div><div><br></div><div><span style=""color: rgb(51, 51, 51);"">Установка значения&nbsp;</span><code>scrollTop</code><span style=""color: rgb(51, 51, 51);"">&nbsp;на&nbsp;</span><code>0</code><span style=""color: rgb(51, 51, 51);"">&nbsp;или&nbsp;</span><code>Infinity</code><span style=""color: rgb(51, 51, 51);"">&nbsp;прокрутит элемент в самый верх/низ соответственно.</span><br></div></div>"	dom
"{{c1::<code>offsetParent</code><span style=""color: rgb(51, 51, 51);"">&nbsp;</span>}}<span style=""color: rgb(51, 51, 51);"">– ближайший CSS-позиционированный родитель или ближайший&nbsp;</span><code>td</code><span style=""color: rgb(51, 51, 51);"">,&nbsp;</span><code>th</code><span style=""color: rgb(51, 51, 51);"">,&nbsp;</span><code>table</code><span style=""color: rgb(51, 51, 51);"">,&nbsp;</span><code>body</code>"	<div>В свойстве&nbsp;<code>offsetParent</code>&nbsp;находится предок элемента, который используется внутри браузера для вычисления координат при рендеринге.</div><div>То есть, ближайший предок, который удовлетворяет следующим условиям:</div><ol><li>Является CSS-позиционированным (CSS-свойство&nbsp;<code>position</code>&nbsp;равно&nbsp;<code>absolute</code>,&nbsp;<code>relative</code>,&nbsp;<code>fixed</code>&nbsp;или&nbsp;<code>sticky</code>),</li><li>или&nbsp;<code>&lt;td&gt;</code>,&nbsp;<code>&lt;th&gt;</code>,&nbsp;<code>&lt;table&gt;</code>,</li><li>или&nbsp;<code>&lt;body&gt;</code>.</li></ol>	dom
Как узнать ширину полосы прокрутки?	"Создать элемент без border и padding.&nbsp;<span style=""color: rgb(51, 51, 51);"">Тогда разница между его полной шириной&nbsp;</span><code>offsetWidth</code><span style=""color: rgb(51, 51, 51);"">&nbsp;и шириной внутреннего содержимого&nbsp;</span><code>clientWidth</code><span style=""color: rgb(51, 51, 51);"">&nbsp;будет равна как раз прокрутке.</span>"	dom
<div>В чём отличие между&nbsp;<code>getComputedStyle(elem).width</code>&nbsp;и&nbsp;<code>elem.clientWidth</code>?</div><div>Укажите хотя бы 3 отличия, лучше – больше.</div>	"<div>Отличия:</div><ol><li><code>clientWidth</code>&nbsp;возвращает число, а&nbsp;<code>getComputedStyle(elem).width</code>&nbsp;– строку с&nbsp;<code>px</code>&nbsp;на конце.</li><li><code>getComputedStyle</code>&nbsp;не всегда даст ширину, он может вернуть, к примеру,&nbsp;<code>""auto""</code>&nbsp;для строчного элемента.</li><li><code>clientWidth</code>&nbsp;соответствует внутренней области элемента, включая внутренние отступы&nbsp;<code>padding</code>, а CSS-ширина (при стандартном значении&nbsp;<code>box-sizing</code>) соответствует внутренней области&nbsp;<em>без внутренних отступов</em>&nbsp;<code>padding</code>.</li><li>Если есть полоса прокрутки, и для неё зарезервировано место, то некоторые браузеры вычитают его из CSS-ширины (т.к. оно больше недоступно для содержимого), а некоторые – нет. Свойство&nbsp;<code>clientWidth</code>&nbsp;всегда ведёт себя одинаково: оно всегда обозначает размер за вычетом прокрутки, т.е. реально доступный для содержимого.</li></ol>"	dom
Как выбрать корневой элемент документа?	document.documentElement (соответствует тегу &lt;html&gt;)	dom
"Как <span style=""color: rgb(51, 51, 51);"">получить ширину/высоту окна браузера?</span>"	"<span style=""color: rgb(51, 51, 51);"">взять свойства&nbsp;</span><code>clientWidth/clientHeight</code><span style=""color: rgb(51, 51, 51);"">&nbsp;из&nbsp;</span><code>document.documentElement</code>"	dom
С какого тега начинается любой html документ?	"<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">&lt;!DOCTYPE HTML&gt;</span>"	dom
Как получить ширину/высоту документа?	"<div>Ширина&nbsp;<span style=""background-color: rgb(245, 242, 240); color: rgb(51, 51, 51);"">documentElement.scrollWidth</span></div><div><br></div>Из-за несоответствий и несовершенства JS, чтобы надёжно получить полную высоту документа, нам следует взять максимальное из этих свойств:<div><br></div><div><pre><code><code>let</code> </code>scrollHeight = Math.max(   document.body.scrollHeight, document.documentElement.scrollHeight,   document.body.of<code><code><code><code><code><code><code><code><code><code><code><code>fsetHeight,</code> document.</code>documentElement.</code>offsetHeight,</code>   document.</code>body.</code>clientHeight,</code> document.</code>documentElement.</code>clientHeight )</code>;</code></code></pre></div>"	dom
Как получить текущую прокрутку окна?	"<span style=""color: rgb(51, 51, 51);"">Из свойств&nbsp;</span><code>window.pageXOffset/pageYOffset</code>"	dom
Как прокрутить окно браузера из кода?	<div>Мы можем сделать то же самое для страницы в целом, используя&nbsp;<code>document.documentElement.scrollTop/Left</code>&nbsp;(кроме основанных на старом WebKit (Safari), где, из-за несовместимостей нужно использовать,&nbsp;<code>document.body.scrollTop/Left</code>).</div><div>Есть и другие способы, в которых подобных несовместимостей нет: специальные методы&nbsp;<code>window.scrollBy(x,y)</code>&nbsp;и&nbsp;<code>window.scrollTo(pageX,pageY)</code>.</div><ul><li><div>Метод&nbsp;<code>scrollBy(x,y)</code>&nbsp;прокручивает страницу&nbsp;<em>относительно её текущего положения</em>. Например,&nbsp;<code>scrollBy(0,10)</code>&nbsp;прокручивает страницу на&nbsp;<code>10px</code>&nbsp;вниз.</div><div>Кнопка ниже демонстрирует это:</div><div>window.scrollBy(0,10)</div></li><li><div>Метод&nbsp;<code>scrollTo(pageX,pageY)</code>&nbsp;прокручивает страницу&nbsp;<em>на абсолютные координаты</em>&nbsp;<code>(pageX,pageY)</code>. То есть, чтобы левый-верхний угол видимой части страницы имел данные координаты относительно левого верхнего угла документа. Это всё равно, что поставить&nbsp;<code>scrollLeft/scrollTop</code>. Для прокрутки в самое начало мы можем использовать&nbsp;<code>scrollTo(0,0)</code>.</div><div>window.scrollTo(0,0)</div></li></ul><div>Эти методы одинаково работают для всех браузеров.</div>	dom
"<span style=""color: rgb(51, 51, 51);"">Чтобы запретить прокрутку страницы, достаточно установить&nbsp;</span><code>{{c1::document.body.style.overflow}} = ""hidden""</code><span style=""color: rgb(51, 51, 51);"">.</span>"	"Возобновить прокрутку&nbsp;<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">document.body.style.overflow = """"</span><div><span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);""><br></span></div><div>При остановке прокрутки изчезает полоса прокрутки и текст может прыгнуть вправо. Чтобы этого не было нужно проверять, если изменился clientWidth после остановки, то добавлять padding размером с полосу прокрутки.</div>"	dom
"<span style=""color: rgb(51, 51, 51);"">Большинство соответствующих методов JavaScript работают в одной из двух указанных ниже систем координат:</span>"	"<ol><li><strong>Относительно окна браузера</strong>&nbsp;– как&nbsp;<code>position:fixed</code>, отсчёт идёт от верхнего левого угла окна.<ul><li>мы будем обозначать эти координаты как&nbsp;<code>clientX/clientY</code>, причина выбора таких имён будет ясна позже, когда мы изучим свойства событий.</li></ul></li><li><strong>Относительно документа</strong>&nbsp;– как&nbsp;<code>position:absolute</code>&nbsp;на уровне документа, отсчёт идёт от верхнего левого угла документа.</li><ul><li>мы будем обозначать эти координаты как&nbsp;<code>pageX/pageY</code>.</li></ul></ol><div><img src=""paste-e3df7c339d57d507a1e4b92677ffd484ccc0a7d1.jpg""><br></div>"	dom
Как определить координаты элемента относительно окна?	"<div>Метод&nbsp;<code>elem.getBoundingClientRect()</code>&nbsp;возвращает координаты в контексте окна для минимального по размеру прямоугольника, который заключает в себе элемент&nbsp;<code>elem</code>, в виде объекта встроенного класса&nbsp;<a href=""https://www.w3.org/TR/geometry-1/#domrect"">DOMRect</a>.</div><div>Основные свойства объекта типа&nbsp;<code>DOMRect</code>:</div><ul><li><code>x/y</code>&nbsp;– X/Y-координаты начала прямоугольника относительно окна,</li><li><code>width/height</code>&nbsp;– ширина/высота прямоугольника (могут быть отрицательными).</li></ul><div><img src=""paste-8a92a226819f6c87418ed49f7ab090adc53380c4.jpg""><br></div>"	dom
"<span style=""color: rgb(51, 51, 51);"">Вызов&nbsp;</span><code>document.elementFromPoint(x, y)</code><span style=""color: rgb(51, 51, 51);"">&nbsp;возвращает&nbsp;</span>{{c1::<span style=""color: rgb(51, 51, 51);"">самый глубоко вложенный элемент в окне, находящийся по координатам&nbsp;</span><code>(x, y)</code>}}<span style=""color: rgb(51, 51, 51);"">.</span>"		dom
"<span style=""color: rgb(51, 51, 51);"">В CSS координаты относительно окна браузера соответствуют свойству&nbsp;</span><code>position:{{c1::fixed}}</code><span style=""color: rgb(51, 51, 51);"">, а координаты относительно документа – свойству&nbsp;</span><code>position:{{c1::absolute}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;на самом верхнем уровне вложенности.</span>"		dom
<div>Две системы координат связаны следующими формулами:</div><ul><li><code>pageY</code>&nbsp;=&nbsp;<code>clientY</code>&nbsp;+ {{c1::высота вертикально прокрученной части документа}}.</li><li><code>pageX</code>&nbsp;=&nbsp;<code>clientX</code>&nbsp;+ {{c1::ширина горизонтально прокрученной части документа}}.</li></ul>		dom
Событие {{c1::<code>click</code>&nbsp;}} – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).<br><br>		events
"<code>{{c1::contextmenu}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– происходит, когда кликнули на элемент правой кнопкой мыши.</span>"		events
"{{c1::<code>mouseover</code><span style=""color: rgb(51, 51, 51);"">&nbsp;/&nbsp;</span><code>mouseout</code>}}<span style=""color: rgb(51, 51, 51);"">&nbsp;– когда мышь наводится на / покидает элемент.</span>"		events
"{{c1::<code>mousedown</code><span style=""color: rgb(51, 51, 51);"">&nbsp;/&nbsp;</span><code>mouseup</code>}}<span style=""color: rgb(51, 51, 51);"">&nbsp;– когда нажали / отжали кнопку мыши на элементе.</span>"		events
"<code>{{c1::mousemove}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– при движении мыши.</span>"		events
"<code>Событие {{c1::submit}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– пользователь отправил форму&nbsp;</span><code>&lt;form&gt;</code><span style=""color: rgb(51, 51, 51);"">.</span>"		events
"Событие {{c1::<code>focus</code><span style=""color: rgb(51, 51, 51);"">&nbsp;</span>}}<span style=""color: rgb(51, 51, 51);"">– пользователь фокусируется на элементе, например нажимает на&nbsp;</span><code>&lt;input&gt;</code>"		events
"<code>{{c1::keydown}}</code><span style=""color: rgb(51, 51, 51);"">&nbsp;и&nbsp;</span>{{c1::<code>keyup</code><span style=""color: rgb(51, 51, 51);"">&nbsp;</span>}}<span style=""color: rgb(51, 51, 51);"">– когда пользователь нажимает / отпускает клавишу.</span>"		events
"{{c1::<code>DOMContentLoaded</code><span style=""color: rgb(51, 51, 51);"">&nbsp;</span>}}<span style=""color: rgb(51, 51, 51);"">– когда HTML загружен и обработан, DOM документа полностью построен и доступен</span>"		events
"{{c1::<code>transitionend</code><span style=""color: rgb(51, 51, 51);"">&nbsp;</span>}}<span style=""color: rgb(51, 51, 51);"">– когда CSS-анимация завершена</span>"		events
"<span style=""color: rgb(51, 51, 51);"">Событию можно назначить&nbsp;</span>{{c1::обработчик}}<span style=""color: rgb(51, 51, 51);"">, то есть функцию, которая сработает, как только событие произошло.</span>"		events
"<span style=""color: rgb(51, 51, 51);"">Обработчик может быть назначен прямо в разметке, в атрибуте, который называется&nbsp;</span><code>{{c1::on&lt;событие&gt;}}</code><span style=""color: rgb(51, 51, 51);"">.</span>"		events
"<span style=""color: rgb(51, 51, 51);"">Можно назначать обработчик, используя свойство DOM-элемента&nbsp;</span><code>{{c1::on&lt;событие&gt;}}</code>"	"<div>К примеру,&nbsp;<code>elem.onclick</code>:</div><div><div><div><pre><code><code><code><code>&lt;</code>input</code> <code>id</code><code><code>=</code><code>""</code>elem<code>""</code></code> <code>type</code><code><code>=</code><code>""</code>button<code>""</code></code> <code>value</code><code><code>=</code><code>""</code>Нажми меня!<code>""</code></code><code>&gt;</code></code> <code><code><code>&lt;</code>script</code><code>&gt;</code></code><code><code>   elem<code>.</code><code>onclick</code> <code>=</code> <code>function</code><code>(</code><code>)</code> <code>{</code>     <code>alert</code><code>(</code><code>'Спасибо'</code><code>)</code><code>;</code>   <code>}</code><code>;</code> </code></code><code><code><code>&lt;/</code>script</code><code>&gt;</code></code></code></pre></div></div></div>"	events
"<span style=""color: rgb(51, 51, 51);"">Убрать обработчик можно назначением&nbsp;</span><code>elem.onclick = {{c1::null}}</code><span style=""color: rgb(51, 51, 51);"">.</span>"		events
"<span style=""color: rgb(51, 51, 51);"">Внутри обработчика события&nbsp;</span><code>this</code><span style=""color: rgb(51, 51, 51);"">&nbsp;ссылается на&nbsp;</span>{{c1::текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик}}<span style=""color: rgb(51, 51, 51);"">.</span>"	"<div>&nbsp;коде ниже&nbsp;<code>button</code>&nbsp;выводит своё содержимое, используя&nbsp;<code>this.innerHTML</code>:</div><div><div><div><pre><code><code><code><code>&lt;</code>button</code> <code>onclick</code><code><code>=</code><code>""</code>alert(this.innerHTML)<code>""</code></code><code>&gt;</code></code>Нажми меня<code><code><code>&lt;/</code>button</code><code>&gt;</code></code></code></pre></div></div></div>"	events
<pre><code><code>Как правильно?</code></code></pre><pre><code> button<code>.</code>onclick <code>=</code> sayThanks<code>;</code> <br></code></pre><pre><code>или</code></pre><pre><code> button<code>.</code>onclick <code>=</code> <code>sayThanks</code><code>(</code><code>)</code><code>;</code></code></pre>	"<span style=""color: rgb(51, 51, 51);"">Если добавить скобки, то&nbsp;</span><code>sayThanks()</code><span style=""color: rgb(51, 51, 51);"">&nbsp;– это уже вызов функции, результат которого (равный&nbsp;</span><code>undefined</code><span style=""color: rgb(51, 51, 51);"">, так как функция ничего не возвращает) будет присвоен&nbsp;</span><code>onclick</code><span style=""color: rgb(51, 51, 51);"">. Так что это не будет работать.</span>"	events
"<pre><code><code><code><code>Как правильно?</code></code></code></code></pre><pre><code><code><code><code>&lt;</code>input</code> <code>type</code><code><code>=</code><code>""</code>button<code>""</code></code> <code>id</code><code><code>=</code><code>""</code>button<code>""</code></code> <code>onclick</code><code><code>=</code><code>""</code>sayThanks()<code>""</code></code><code>&gt;</code></code></code></pre><pre><code><code><code>или</code></code></code></pre><pre><code><code><code><pre><code><code><code><code>&lt;</code>input</code> <code>type</code><code><code>=</code><code>""</code>button<code>""</code></code> <code>id</code><code><code>=</code><code>""</code>button<code>""</code></code> <code>onclick</code><code><code>=</code><code>""</code>sayThanks<code>""</code></code><code>&gt;</code></code></code></pre></code></code></code></pre>"	<div>Это различие просто объяснить. При создании обработчика браузером из атрибута, он автоматически создаёт функцию с&nbsp;<em>телом из значения атрибута</em>:&nbsp;<code>sayThanks()</code>.</div><div>Так что разметка генерирует такое свойство:</div><div><div><div><pre><code> <code> </code></code><code>button<code>.</code><code>onclick</code> <code>=</code> <code>function</code><code>(</code><code>)</code> <code>{</code>   <code>sayThanks</code><code>(</code><code>)</code><code>;</code> <code>// содержимое атрибута</code> <code>}</code><code>;</code></code></pre></div></div></div>	events
"<code>addEventListener</code><span style=""color: rgb(51, 51, 51);"">&nbsp;</span><div><span style=""color: rgb(51, 51, 51);"">Синтаксис добавления обработчика:</span><span style=""color: rgb(51, 51, 51);""><br></span></div>"	"<div><div><div><pre><code>element<code>.</code><code>addEventListener</code><code>(</code>event<code>,</code> handler<code>[</code><code>,</code> options<code>]</code><code>)</code><code>;</code></code><span style=""background-color: rgb(231, 229, 227);""></span></pre></div></div></div><dl><dt><code>event</code></dt><dd>Имя события, например&nbsp;<code>""click""</code>.</dd><dt><code>handler</code></dt><dd>Ссылка на функцию-обработчик.</dd><dt><code>options</code></dt><dd>Дополнительный объект со свойствами:<ul><li><code>once</code>: если&nbsp;<code>true</code>, тогда обработчик будет автоматически удалён после выполнения.</li><li><code>capture</code>: фаза, на которой должен сработать обработчик.</li><li><code>passive</code>: если&nbsp;<code>true</code>, то указывает, что обработчик никогда не вызовет&nbsp;<code>preventDefault()</code>,</li></ul></dd></dl>"	events
"<span style=""color: rgb(51, 51, 51);"">Для удаления обработчика следует использовать</span>"	<div><code>removeEventListener</code>:</div><div><div><div><pre><code>element<code>.</code><code>removeEventListener</code><code>(</code>event<code>,</code> handler<code>[</code><code>,</code> options<code>]</code><code>)</code><code>;</code></code></pre></div></div></div>	events
"Сработает ли?<div><br></div><div><pre><code>elem<code>.</code><code>addEventListener</code><code>(</code> <code>""click""</code> <code>,</code> <code>(</code><code>)</code> <code>=&gt;</code> <code>alert</code><code>(</code><code>'Спасибо!'</code><code>)</code><code>)</code><code>;</code> <code>// ....</code> elem<code>.</code><code>removeEventListener</code><code>(</code> <code>""click""</code><code>,</code> <code>(</code><code>)</code> <code>=&gt;</code> <code>alert</code><code>(</code><code>'Спасибо!'</code><code>)</code><code>)</code><code>;</code></code></pre></div>"	"Нет.&nbsp;<span style=""color: rgb(51, 51, 51);"">Для удаления нужно передать именно ту функцию-обработчик которая была назначена.</span><div><span style=""color: rgb(51, 51, 51);""><br></span></div><div><div>Вот так правильно:</div><div><div><div><pre><code><code>function</code> <code>handler</code><code>(</code><code>)</code> <code>{</code>   <code>alert</code><code>(</code> <code>'Спасибо!'</code> <code>)</code><code>;</code> <code>}</code>  input<code>.</code><code>addEventListener</code><code>(</code><code>""click""</code><code>,</code> handler<code>)</code><code>;</code> <code>// ....</code> input<code>.</code><code>removeEventListener</code><code>(</code><code>""click""</code><code>,</code> handler<code>)</code><code>;</code></code></pre></div></div></div></div>"	events
Какими способами можно добавить обработчик к событию?	1. Через html атрибут onclick =&nbsp;<div>2. Через свойство button.onclick =&nbsp;</div><div>3. Через addEventListener (можно добавлять несколько обработчиков на одно событие)</div>	events
<div>Существуют события, которые нельзя назначить через DOM-свойство, но можно через&nbsp;<code>addEventListener</code>.</div><div>Например,&nbsp;</div>	"<div>событие&nbsp;<code>DOMContentLoaded</code>, которое срабатывает, когда завершена загрузка и построение DOM документа.</div><div><div><div><pre><code>document<code>.</code><code>onDOMContentLoaded</code> <code>=</code> <code>function</code><code>(</code><code>)</code> <code>{</code>   <code>alert</code><code>(</code><code>""DOM построен""</code><code>)</code><code>;</code> <code>// не будет работать</code> <code>}</code><code>;</code></code><span style=""background-color: rgb(231, 229, 227);""></span></pre></div></div></div><div><div><div><pre><code>document<code>.</code><code>addEventListener</code><code>(</code><code>""DOMContentLoaded""</code><code>,</code> <code>function</code><code>(</code><code>)</code> <code>{</code>   <code>alert</code><code>(</code><code>""DOM построен""</code><code>)</code><code>;</code> <code>// а вот так сработает</code> <code>}</code><code>)</code><code>;</code></code></pre></div></div></div>"	events
"<span style=""color: rgb(51, 51, 51);"">Когда происходит событие, браузер создаёт&nbsp;</span>{{c1::объект события}}<span style=""color: rgb(51, 51, 51);"">, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.</span>"		events
"<span style=""color: rgb(51, 51, 51); font-weight: 700; background-color: rgb(245, 242, 240);"">event.type</span>"	"<span style=""color: rgb(51, 51, 51);"">Тип события, например&nbsp;</span><code>""click""</code><span style=""color: rgb(51, 51, 51);"">.</span>"	events
"<span style=""color: rgb(51, 51, 51); font-weight: 700; background-color: rgb(245, 242, 240);"">event.currentTarget</span>"	"<span style=""color: rgb(51, 51, 51);"">Элемент, на котором сработал обработчик. Значение – обычно такое же, как и у&nbsp;</span><code>this</code><span style=""color: rgb(51, 51, 51);"">, но если обработчик является функцией-стрелкой или при помощи&nbsp;</span><code>bind</code><span style=""color: rgb(51, 51, 51);"">&nbsp;привязан другой объект в качестве&nbsp;</span><code>this</code><span style=""color: rgb(51, 51, 51);"">, то мы можем получить элемент из&nbsp;</span><code>event.currentTarget</code><span style=""color: rgb(51, 51, 51);"">.</span>"	events
"<span style=""color: rgb(51, 51, 51); font-weight: 700; background-color: rgb(245, 242, 240);"">event.clientX / event.clientY</span>"	"<span style=""color: rgb(51, 51, 51);"">Координаты курсора в момент клика относительно окна, для событий мыши.</span>"	events
"<span style=""color: rgb(51, 51, 51);"">Мы можем назначить обработчиком не только функцию, но и объект при помощи&nbsp;</span><code>addEventListener</code><span style=""color: rgb(51, 51, 51);"">. В этом случае, когда происходит событие, вызывается&nbsp;</span>{{c1::<span style=""color: rgb(51, 51, 51);"">метод объекта&nbsp;</span><code>handleEvent</code>}}<span style=""color: rgb(51, 51, 51);"">.</span>"		events
"<div>Который из обработчиков запустится? Что будет выведено при клике после выполнения кода?</div><div><div><div><pre><code>button<code>.</code><code>addEventListener</code><code>(</code><code>""click""</code><code>,</code> <code>(</code><code>)</code> <code>=&gt;</code> <code>alert</code><code>(</code><code>""1""</code><code>)</code><code>)</code><code>;</code>  button<code>.</code><code>removeEventListener</code><code>(</code><code>""click""</code><code>,</code> <code>(</code><code>)</code> <code>=&gt;</code> <code>alert</code><code>(</code><code>""1""</code><code>)</code><code>)</code><code>;</code>  button<code>.</code><code>onclick</code> <code>=</code> <code>(</code><code>)</code> <code>=&gt;</code> <code>alert</code><code>(</code><code>2</code><code>)</code><code>;</code></code></pre></div></div></div>"	"<span style=""color: rgb(51, 51, 51);"">Ответ:&nbsp;</span><code>1</code><span style=""color: rgb(51, 51, 51);"">&nbsp;и&nbsp;</span><code>2</code><span style=""color: rgb(51, 51, 51);"">.</span><div><span style=""color: rgb(51, 51, 51);""><br></span></div><div><span style=""color: rgb(51, 51, 51);"">Первый обработчик сработает, потому что он не был удалён методом&nbsp;</span><code>removeEventListener</code><span style=""color: rgb(51, 51, 51);"">.</span><span style=""color: rgb(51, 51, 51);""><br></span></div><div><span style=""color: rgb(51, 51, 51);"">Обработчик&nbsp;</span><code>button.onclick</code><span style=""color: rgb(51, 51, 51);"">&nbsp;сработает независимо от&nbsp;</span><code>addEventListener</code><span style=""color: rgb(51, 51, 51);"">.</span><span style=""color: rgb(51, 51, 51);""><br></span></div>"	events
What is the difference between appendChild, insertAdjacentHTML, and innerHTML?	"<ul><li><div><a href=""https://developer.mozilla.org/en-US/docs/DOM/element.innerHTML""><code>element.innerHTML</code></a></div><div><strong>From MDN:</strong></div><blockquote><div>innerHTML sets or gets the HTML syntax describing the element's descendants.</div></blockquote><div>when writing to&nbsp;<em><code>innerHTML</code></em>, it will overwrite the content of the source element. That means the HTML has to be loaded and re-parsed. This is not very efficient especially when using inside loops.</div></li><li><div><a href=""https://developer.mozilla.org/en-US/docs/DOM/Node.appendChild""><code>node.appendChild</code></a></div><div><strong>From MDN:</strong></div><blockquote><div>Adds a node to the end of the list of children of a specified parent node. If the node already exists it is removed from current parent node, then added to new parent node.</div></blockquote><div>This method is supported by all browsers and is a much cleaner way of inserting nodes, text, data, etc. into the DOM.</div></li><li><div><a href=""https://developer.mozilla.org/en-US/docs/DOM/element.insertAdjacentHTML""><code>element.insertAdjacentHTML</code></a></div><div><strong>From MDN:</strong></div><blockquote><div>parses the specified text as HTML or XML and inserts the resulting nodes into the DOM tree at a specified position.&nbsp;<em>[ ... ]</em></div></blockquote><div>This method is also supported by all browsers.</div></li></ul>"	dom
Всплытие - это?	Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.	events
Целевой элемент при всплытии - ?	Самый глубокий элемент, который вызывает событие, называется&nbsp;целевым&nbsp;элементом, и он доступен через&nbsp;event.target.	events
event.target при всплытии?	Самый глубокий элемент, который вызывает событие, называется&nbsp;целевым&nbsp;элементом, и он доступен через&nbsp;event.target. В&nbsp;процессе всплытия он неизменен.	events
event.target vs this при всплытии	<div>Отличия от&nbsp;<code>this</code>&nbsp;(=<code>event.currentTarget</code>):</div><ul><li><code>event.target</code>&nbsp;– это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.</li><li><code>this</code>&nbsp;– это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.</li></ul>	events
Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента&nbsp;{{c1::&lt;html&gt;}}, а затем до объекта&nbsp;{{c1::document}}, а иногда даже до&nbsp;{{c1::window}}, вызывая все обработчики на своём пути.		events
Прекращение всплытия - метод	"<span style=""color: rgb(51, 51, 51); background-color: rgb(245, 242, 240);"">event.stopPropagation()</span>"	events
event.stopImmediatePropagation()	<div>Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.</div><div>То есть,&nbsp;<code>event.stopPropagation()</code>&nbsp;препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.</div><div>Для того, чтобы полностью остановить обработку, существует метод&nbsp;<code>event.stopImmediatePropagation()</code>. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.</div>	events
Подводные камни event.stopPropagation()	"Если остановить распространение события, то появляются ""мертвые зоны"" для систем аналитики кликов."	events
<div>Стандарт&nbsp;DOM Events&nbsp;описывает 3 фазы прохода события:</div>	"<ol><li>Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.</li><li>Фаза цели (target phase) – событие достигло целевого(исходного) элемента.</li><li>Фаза всплытия (bubbling stage) – событие начинает всплывать.</li></ol><div><img src=""paste-ea6e09024badac338b51200f86d086b547b739f8.jpg""><br></div>"	events
"<span style=""color: rgb(51, 51, 51);"">Чтобы поймать событие на стадии погружения, нужно использовать</span>"	"<div>третий аргумент&nbsp;<code>capture</code>&nbsp;вот так:</div><div><div><div><pre><code>elem<code>.</code><code>addEventListener</code><code>(</code><code>...</code><code>,</code> <code>{</code>capture<code>:</code> <code>true</code><code>}</code><code>)</code> <code>// или просто ""true"", как сокращение для {capture: true}</code> elem<code>.</code><code>addEventListener</code><code>(</code><code>...</code><code>,</code> <code>true</code><code>)</code></code><span style=""background-color: rgb(231, 229, 227);""></span></pre></div></div></div><div>Существуют два варианта значений опции&nbsp;<code>capture</code>:</div><ul><li>Если аргумент&nbsp;<code>false</code>&nbsp;(по умолчанию), то событие будет поймано при всплытии.</li><li>Если аргумент&nbsp;<code>true</code>, то событие будет перехвачено при погружении.</li></ul>"	events